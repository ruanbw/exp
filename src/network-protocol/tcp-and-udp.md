## tcp 与 udp 的区别

为了让区别更形象，我们先用一个经典的比喻：
- TCP (Transmission Control Protocol, 传输控制协议) = 打电话
- UDP (User Datagram Protocol, 用户数据报协议) = 寄明信片
现在，我们围绕这个比喻展开，深入到技术细节中。

### 一、核心区别：打电话 vs. 寄明信片
| 特性         | TCP (打电话)            | UDP (寄明信片)          |
|--------------|-------------------------|-------------------------|
| 连接性      | 面向连接 (Connection-Oriented) | 无连接 (Connectionless) |
| 可靠性      | 可靠                    | 不可靠                  |
| 速度        | 慢                      | 快                      |
| 资源消耗    | 高                      | 低                      |
| 数据格式    | 流 (Stream)            | 数据报 (Datagram)      |
### 二、详细拆解各项区别
#### 1. 连接性 (Connection)
TCP (打电话): 在你开始说话（传输数据）之前，你必须先拨号，等待对方接听，说“喂？”，你也说“喂？”，确认双方线路通畅。这个过程就是TCP的三次握手。通话结束后，你会说“再见”，然后挂断电话，这是一个四次挥手的断开过程。整个通信期间，这条连接会一直维持。
UDP (寄明信片): 你只需要在明信片上写好地址，然后把它扔进邮筒就行了。你不需要提前确认收件人是否在家，也不需要知道他是否收到了。你寄下一张明信片时，走的可能是完全不同的邮路。每次发送都是独立的，没有“连接”这个概念。
#### 2. 可靠性 (Reliability)
TCP (打电话):
确认与重传: 你说话时，对方会时不时地用“嗯”、“好的”来回应，让你知道他听到了。如果对方没反应，你会重复一遍：“喂？你听到了吗？” 这就是 TCP 的确认(ACK)和超时重传机制。服务器发送数据包后，会等待客户端的确认，如果没收到就会重新发送。
有序性: 你讲故事肯定是按照 1-2-3 的顺序讲。TCP 通过**序列号(Sequence Number)**机制，保证接收方收到的数据包能按正确的顺序重组，即使它们在网络中是乱序到达的。
数据完整性: TCP 有**校验和(Checksum)**机制，确保数据在传输过程中没有损坏。如果损坏，该数据包会被丢弃并等待重传。
UDP (寄明信片):
尽力而为 (Best-Effort): 你把明信片寄出去，邮局会尽力去送，但中途可能会丢失、损坏，或者因为邮路不同导致后寄的先到。UDP 就是这样，它只负责把数据包发出去，不保证它是否能到达、何时到达、是否按顺序到达。可靠性需要应用层自己去实现（如果需要的话）。
#### 3. 速度与效率 (Speed & Efficiency)
TCP (打电话): 因为要建立连接、发送确认、处理排序、进行流量控制和拥塞控制，这些机制带来了大量的开销 (Overhead)。就像打电话时礼貌性的问候和确认会占用一些时间一样。因此，TCP 的速度相对较慢，延迟较高。
UDP (寄明信片): 它没有这些复杂的机制，拿上数据，加上一个很小的头部（包含端口和校验和等基本信息），就直接扔到网络里。没有握手，没有确认，没有重传。因此，它的开销极小，速度非常快，延迟低。
#### 4. 流量控制与拥塞控制 (Flow & Congestion Control)
TCP:
流量控制 (Flow Control): 如果你说话太快，对方听不过来，他会说“慢点，慢点”。TCP 使用**滑动窗口(Sliding Window)**机制，接收方会告诉发送方自己还能接收多少数据，防止发送方过快地发送数据撑爆接收方的缓冲区。
拥塞控制 (Congestion Control): 如果你和朋友打电话时，发现信号不好，声音断断续续（网络拥堵），你们可能会放慢语速或者先不说话。TCP 有一套复杂的算法（如慢启动、拥塞避免），当检测到网络拥堵时，会主动降低发送速率，避免加剧网络瘫痪。
UDP: 完全没有这些机制。它会按照应用产生的速度持续发送数据，不管接收方是否能处理，也不管网络是否拥堵。这可能会导致网络状况恶化，也可能导致大量丢包。
#### 5. 头部开销 (Header Size)
TCP: 头部较大，通常为 20 字节或更多（因为有各种选项字段）。
UDP: 头部非常小，固定为 8 字节。
### 三、应用场景：什么时候用谁？

这是最重要的部分，理解了场景，就真正理解了它们的区别。

使用 TCP 的场景 (质量优先)

- 核心要求：数据必须准确无误、完整且有序。
- 网页浏览 (HTTP/HTTPS): 你浏览网页，一个字、一张图片都不能错。如果 CSS 文件少了一行，页面可能就乱了。所以 HTTP 协议是构建在 TCP 之上的。
- 文件传输 (FTP): 下载一个软件，如果少了一个字节，整个程序可能就无法运行。
- 电子邮件 (SMTP, POP3, IMAP): 你肯定不希望你的邮件内容丢失或乱序。
- 远程登录 (SSH, Telnet): 你输入的每一个命令，返回的每一个字符，都必须准确无误。
- 使用 UDP 的场景 (速度优先)
- 核心要求：实时性要求高，可以容忍少量数据丢失。
- 在线游戏: 你玩 FPS 游戏，最重要的是快速看到对手的位置。如果因为网络抖动，某一帧画面（一个数据包）丢失了，问题不大，因为下一帧马上就来了。但如果为了等丢失的那个包而卡顿一下，你可能已经被击败了。
- 视频/语音通话 (VoIP, WebRTC): 和朋友视频聊天，偶尔的马赛克或声音卡顿（丢包）是可以接受的，但不能接受为了等一个丢失的数据包而导致整个画面和声音延迟好几秒。
- 直播: 和视频通话类似，实时性远比偶尔的画质损失更重要。
- DNS (域名系统): 查询一个域名的 IP 地址，这个过程需要非常快。请求和响应的数据包都很小，如果一次查询失败（数据包丢失），客户端简单地再发起一次查询就行了，成本很低。用 TCP 那套复杂的握手机制反而显得小题大做。
- 对前端/Web开发者的特殊意义：HTTP/3 的变革

传统上，我们知道 HTTP/1.1 和 HTTP/2 都是基于 TCP 的。但 TCP 有一个固有的问题叫队头阻塞 (Head-of-Line Blocking)。在一个 TCP 连接上，如果一个数据包丢失了，那么后续所有的数据包（即使已经到达）都必须等待那个丢失的包重传回来，才能被应用层处理。

为了解决这个问题，HTTP/3 做出一个革命性的改变：它不再使用 TCP，而是基于 UDP！

等等，HTTP 不是要求可靠吗？UDP 怎么行？

HTTP/3 的底层协议叫 QUIC (Quick UDP Internet Connections)。QUIC 巧妙地在 UDP 之上，自己实现了一套可靠传输的机制，包括连接管理、加密、拥塞控制和流量控制。这样做的好处是：

解决了队头阻塞: QUIC 在一个连接上可以并行传输多个独立的“流”。如果一个流中的某个数据包丢失，它只会阻塞那个流，不会影响其他流的数据处理。

更快的连接建立: QUIC 将 TCP 的三次握手和 TLS (加密)的握手过程合并，大大减少了连接建立的延迟。

所以，作为现代开发者，需要知道：虽然我们日常打交道的 HTTP 传统上是 TCP 的天下，但未来（其实已经是现在）的 Web 正在向基于 UDP 的 HTTP/3 迁移，以获得更好的性能。
